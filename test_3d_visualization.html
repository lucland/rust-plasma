<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Visualization Test</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
        }
        
        .test-container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .canvas-container {
            width: 100%;
            height: 400px;
            border: 1px solid #ddd;
            border-radius: 4px;
            position: relative;
            background: #1a1a1a;
        }
        
        #test-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            background: #007bff;
            color: white;
            cursor: pointer;
        }
        
        button:hover {
            background: #0056b3;
        }
        
        .status {
            margin-top: 10px;
            padding: 10px;
            border-radius: 4px;
            background: #e9ecef;
        }
        
        .status.success {
            background: #d4edda;
            color: #155724;
        }
        
        .status.error {
            background: #f8d7da;
            color: #721c24;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>3D Visualization Test</h1>
        <p>Testing the Three.js 3D visualization system for the Plasma Furnace Simulator.</p>
        
        <div class="canvas-container">
            <canvas id="test-canvas"></canvas>
        </div>
        
        <div class="controls">
            <button onclick="testBasicScene()">Test Basic Scene</button>
            <button onclick="testFurnaceGeometry()">Test Furnace Geometry</button>
            <button onclick="testHeatmapColors()">Test Heatmap Colors</button>
            <button onclick="resetCamera()">Reset Camera</button>
        </div>
        
        <div id="status" class="status">Ready to test...</div>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        let scene, camera, renderer, controls;
        let furnaceMesh, heatmapMesh;
        let isInitialized = false;

        function updateStatus(message, type = 'info') {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
            console.log(`[Test] ${message}`);
        }

        function init3D() {
            try {
                const canvas = document.getElementById('test-canvas');
                
                // Scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x1a1a1a);
                scene.fog = new THREE.Fog(0x1a1a1a, 10, 50);

                // Camera
                const aspect = canvas.clientWidth / canvas.clientHeight;
                camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
                camera.position.set(5, 3, 5);
                camera.lookAt(0, 1, 0);

                // Renderer
                renderer = new THREE.WebGLRenderer({
                    canvas: canvas,
                    antialias: true,
                    alpha: false
                });
                renderer.setSize(canvas.clientWidth, canvas.clientHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                // Controls
                controls = new THREE.OrbitControls(camera, canvas);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.minDistance = 2;
                controls.maxDistance = 20;
                controls.maxPolarAngle = Math.PI * 0.9;
                controls.target.set(0, 1, 0);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 10, 5);
                directionalLight.castShadow = true;
                scene.add(directionalLight);

                const pointLight = new THREE.PointLight(0xffffff, 0.5, 100);
                pointLight.position.set(-5, 5, -5);
                scene.add(pointLight);

                isInitialized = true;
                updateStatus('3D context initialized successfully!', 'success');
                
                // Start render loop
                animate();
                
                return true;
            } catch (error) {
                updateStatus(`Failed to initialize 3D: ${error.message}`, 'error');
                return false;
            }
        }

        function animate() {
            if (!isInitialized) return;
            
            requestAnimationFrame(animate);
            
            if (controls) {
                controls.update();
            }
            
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }

        function testBasicScene() {
            if (!isInitialized && !init3D()) {
                return;
            }

            // Clear existing objects
            scene.children = scene.children.filter(child => 
                child.type === 'AmbientLight' || 
                child.type === 'DirectionalLight' || 
                child.type === 'PointLight'
            );

            // Add a simple cube
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
            const cube = new THREE.Mesh(geometry, material);
            cube.position.y = 1;
            scene.add(cube);

            updateStatus('Basic scene with cube created', 'success');
        }

        function testFurnaceGeometry() {
            if (!isInitialized && !init3D()) {
                return;
            }

            // Clear existing furnace
            if (furnaceMesh) {
                scene.remove(furnaceMesh);
            }

            // Create cylindrical furnace
            const radius = 1.0;
            const height = 2.0;
            const geometry = new THREE.CylinderGeometry(
                radius, radius, height, 
                32, 16, true
            );

            const wireframeMaterial = new THREE.MeshBasicMaterial({
                color: 0x666666,
                wireframe: true,
                transparent: true,
                opacity: 0.3
            });

            furnaceMesh = new THREE.Mesh(geometry, wireframeMaterial);
            furnaceMesh.position.y = height / 2;
            scene.add(furnaceMesh);

            updateStatus('Furnace geometry created', 'success');
        }

        function testHeatmapColors() {
            if (!isInitialized && !init3D()) {
                return;
            }

            // Clear existing heatmap
            if (heatmapMesh) {
                scene.remove(heatmapMesh);
            }

            // Create heatmap mesh
            const radius = 1.0;
            const height = 2.0;
            const geometry = new THREE.CylinderGeometry(
                radius, radius, height, 
                32, 16, true
            );

            // Add vertex colors
            const positions = geometry.attributes.position;
            const vertexCount = positions.count;
            const colors = new Float32Array(vertexCount * 3);

            for (let i = 0; i < vertexCount; i++) {
                const x = positions.getX(i);
                const y = positions.getY(i);
                const z = positions.getZ(i);
                
                // Create temperature gradient based on height
                const normalizedY = (y + height/2) / height;
                const temperature = normalizedY;
                
                // Convert to heat colors
                let r, g, b;
                if (temperature < 0.25) {
                    const t = temperature / 0.25;
                    r = 0; g = t; b = 1;
                } else if (temperature < 0.5) {
                    const t = (temperature - 0.25) / 0.25;
                    r = 0; g = 1; b = 1 - t;
                } else if (temperature < 0.75) {
                    const t = (temperature - 0.5) / 0.25;
                    r = t; g = 1; b = 0;
                } else {
                    const t = (temperature - 0.75) / 0.25;
                    r = 1; g = 1 - t; b = 0;
                }
                
                colors[i * 3] = r;
                colors[i * 3 + 1] = g;
                colors[i * 3 + 2] = b;
            }

            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.MeshLambertMaterial({
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });

            heatmapMesh = new THREE.Mesh(geometry, material);
            heatmapMesh.position.y = height / 2;
            scene.add(heatmapMesh);

            updateStatus('Heatmap with temperature colors created', 'success');
        }

        function resetCamera() {
            if (!camera || !controls) {
                updateStatus('Camera not initialized', 'error');
                return;
            }

            camera.position.set(5, 3, 5);
            controls.target.set(0, 1, 0);
            controls.update();

            updateStatus('Camera reset to default position', 'success');
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            if (!camera || !renderer) return;
            
            const canvas = document.getElementById('test-canvas');
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        });

        // Initialize on load
        window.addEventListener('load', () => {
            updateStatus('Page loaded, ready to test 3D visualization');
        });
    </script>
</body>
</html>