<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulation Completion Handler Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .test-section h3 {
            margin-top: 0;
        }
        .log {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
        }
        .log-entry {
            margin: 2px 0;
        }
        .log-entry.success { color: green; }
        .log-entry.error { color: red; }
        .log-entry.info { color: blue; }
        button {
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 3px;
        }
        .status.pending { background: #fff3cd; }
        .status.success { background: #d4edda; }
        .status.error { background: #f8d7da; }
    </style>
</head>
<body>
    <h1>Simulation Completion Handler Test</h1>
    
    <div class="test-section">
        <h3>Test Status</h3>
        <div id="test-status" class="status pending">
            Ready to test simulation completion handling
        </div>
    </div>

    <div class="test-section">
        <h3>Test Controls</h3>
        <button onclick="testCompletionHandler()">Test Completion Handler</button>
        <button onclick="testResultsProcessing()">Test Results Processing</button>
        <button onclick="clearLog()">Clear Log</button>
    </div>

    <div class="test-section">
        <h3>Test Log</h3>
        <div id="log" class="log"></div>
    </div>

    <script>
        // Mock EventBus
        class EventBus {
            constructor() {
                this.listeners = {};
            }
            
            on(event, callback) {
                if (!this.listeners[event]) {
                    this.listeners[event] = [];
                }
                this.listeners[event].push(callback);
            }
            
            emit(event, data) {
                log(`EventBus: Emitting '${event}'`, 'info');
                if (this.listeners[event]) {
                    this.listeners[event].forEach(callback => callback(data));
                }
            }
        }

        const eventBus = new EventBus();
        
        // Log function
        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(message);
        }

        function clearLog() {
            document.getElementById('log').innerHTML = '';
        }

        function updateStatus(message, type) {
            const statusDiv = document.getElementById('test-status');
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
        }

        // Mock SimulationController with the new completion handler
        class SimulationController {
            constructor(eventBus) {
                this.eventBus = eventBus;
                this.currentSimulation = null;
            }

            // Simulate having a current simulation
            setCurrentSimulation(id, parameters) {
                this.currentSimulation = {
                    id: id,
                    parameters: parameters,
                    startTime: new Date(),
                    status: 'running',
                    progress: {
                        percent: 100,
                        currentTime: 60,
                        totalTime: 60
                    }
                };
            }

            stopProgressMonitoring() {
                log('Stopped progress monitoring', 'info');
            }

            clearTimeout() {
                log('Cleared timeout', 'info');
            }

            // The actual implementation from simulation.js
            async handleSimulationCompletion(completionPayload) {
                log('üéâ Simulation completed: ' + this.currentSimulation.id, 'success');
                
                if (!this.currentSimulation) {
                    log('No current simulation to complete', 'error');
                    return;
                }
                
                this.currentSimulation.status = 'completed';
                this.currentSimulation.completionTime = new Date();
                
                this.stopProgressMonitoring();
                this.clearTimeout();
                
                try {
                    log('üì° Calling get_simulation_results for: ' + this.currentSimulation.id, 'info');
                    
                    // Mock the Tauri call
                    const resultsResponse = await this.mockGetSimulationResults(this.currentSimulation.id);
                    
                    log('‚úÖ Results retrieved from backend', 'success');
                    
                    const processedResults = this.processResults(resultsResponse.results);
                    
                    log('üîÑ Results processed for visualization', 'success');
                    
                    this.eventBus.emit('simulation:completed', {
                        simulationId: this.currentSimulation.id,
                        results: processedResults,
                        duration: Date.now() - this.currentSimulation.startTime.getTime(),
                        progress: this.currentSimulation.progress,
                        parameters: this.currentSimulation.parameters
                    });
                    
                    log('üì° Emitted simulation:completed event to visualization panel', 'success');
                    
                } catch (error) {
                    log('‚ùå Failed to get results: ' + error.message, 'error');
                    
                    this.eventBus.emit('simulation:error', {
                        type: 'results_failed',
                        message: 'Failed to retrieve simulation results from backend',
                        simulationId: this.currentSimulation.id,
                        error: error.message
                    });
                    
                    throw error;
                }
            }

            // Mock Tauri backend call
            async mockGetSimulationResults(simulationId) {
                return {
                    simulation_id: simulationId,
                    status: 'completed',
                    results: {
                        temperature: {
                            min: 300,
                            max: 1200,
                            data: this.generateMockTemperatureData()
                        },
                        metadata: {
                            total_time: 60,
                            time_steps: 120,
                            completion_time: new Date().toISOString(),
                            mesh_resolution: [10, 10]
                        }
                    }
                };
            }

            generateMockTemperatureData() {
                const data = [];
                for (let i = 0; i < 10; i++) {
                    const row = [];
                    for (let j = 0; j < 10; j++) {
                        const distance = Math.sqrt((i - 5) ** 2 + (j - 5) ** 2);
                        const temp = 300 + (900 * Math.exp(-distance / 3));
                        row.push(temp);
                    }
                    data.push(row);
                }
                return data;
            }

            // The actual processResults implementation
            processResults(rawResults) {
                log('üîÑ Processing backend results...', 'info');
                
                if (!rawResults) {
                    throw new Error('No simulation results available from backend');
                }

                const metadata = rawResults.metadata || {};
                const totalTime = metadata.total_time || this.currentSimulation.parameters?.simulation?.duration || 60;
                const timeStepsCompleted = metadata.time_steps || 0;
                
                log('üìä Backend metadata: totalTime=' + totalTime + ', timeSteps=' + timeStepsCompleted, 'info');

                const timeSteps = [];
                const timeStepInterval = timeStepsCompleted > 0 ? totalTime / timeStepsCompleted : 0.5;
                
                for (let i = 0; i < timeStepsCompleted; i++) {
                    timeSteps.push({
                        time: i * timeStepInterval,
                        step: i
                    });
                }
                
                log('‚è±Ô∏è Generated ' + timeSteps.length + ' time steps', 'info');

                const temperatureData = rawResults.temperature?.data || [];
                
                log('üå°Ô∏è Temperature data: ' + temperatureData.length + ' rows', 'info');

                const processedResults = {
                    timeSteps: timeSteps,
                    duration: totalTime,
                    temperatureData: temperatureData,
                    meshData: rawResults.mesh_data || null,
                    metadata: {
                        parameters: this.currentSimulation.parameters,
                        completionTime: metadata.completion_time || new Date().toISOString(),
                        simulationId: this.currentSimulation.id,
                        totalTime: totalTime,
                        timeStepsCompleted: timeStepsCompleted,
                        meshResolution: metadata.mesh_resolution || null,
                        temperatureRange: {
                            min: rawResults.temperature?.min || 300,
                            max: rawResults.temperature?.max || 2000
                        }
                    }
                };
                
                log('‚úÖ Results processed successfully', 'success');

                return processedResults;
            }
        }

        // Create controller instance
        const controller = new SimulationController(eventBus);

        // Listen for simulation:completed event
        eventBus.on('simulation:completed', (data) => {
            log('‚úÖ Visualization received simulation:completed event', 'success');
            log('   - Simulation ID: ' + data.simulationId, 'info');
            log('   - Time steps: ' + data.results.timeSteps.length, 'info');
            log('   - Duration: ' + data.results.duration + 's', 'info');
            log('   - Temperature data rows: ' + data.results.temperatureData.length, 'info');
            log('   - Temperature range: ' + data.results.metadata.temperatureRange.min + 'K - ' + data.results.metadata.temperatureRange.max + 'K', 'info');
            updateStatus('‚úÖ Test passed! Completion handler working correctly', 'success');
        });

        // Listen for simulation:error event
        eventBus.on('simulation:error', (data) => {
            log('‚ùå Error event received: ' + data.message, 'error');
            updateStatus('‚ùå Test failed: ' + data.message, 'error');
        });

        // Test functions
        async function testCompletionHandler() {
            clearLog();
            updateStatus('Running completion handler test...', 'pending');
            log('=== Starting Completion Handler Test ===', 'info');
            
            // Set up a mock simulation
            controller.setCurrentSimulation('test-sim-123', {
                furnace: { height: 2.0, radius: 1.0 },
                torch: { position: { r: 0.5, z: 0.5 }, power: 150 },
                simulation: { duration: 60, timeStep: 0.5 }
            });
            
            log('Created mock simulation: test-sim-123', 'info');
            
            // Simulate completion event
            const completionPayload = {
                simulation_id: 'test-sim-123'
            };
            
            try {
                await controller.handleSimulationCompletion(completionPayload);
                log('=== Test Completed ===', 'success');
            } catch (error) {
                log('=== Test Failed ===', 'error');
                log('Error: ' + error.message, 'error');
                updateStatus('‚ùå Test failed: ' + error.message, 'error');
            }
        }

        async function testResultsProcessing() {
            clearLog();
            updateStatus('Running results processing test...', 'pending');
            log('=== Starting Results Processing Test ===', 'info');
            
            controller.setCurrentSimulation('test-sim-456', {
                simulation: { duration: 60 }
            });
            
            const mockResults = {
                temperature: {
                    min: 300,
                    max: 1500,
                    data: [[300, 400], [500, 600]]
                },
                metadata: {
                    total_time: 60,
                    time_steps: 120,
                    mesh_resolution: [10, 10]
                }
            };
            
            try {
                const processed = controller.processResults(mockResults);
                
                log('Processed results:', 'info');
                log('  - Time steps: ' + processed.timeSteps.length, 'info');
                log('  - Duration: ' + processed.duration, 'info');
                log('  - Temperature data: ' + JSON.stringify(processed.temperatureData), 'info');
                log('  - Metadata: ' + JSON.stringify(processed.metadata, null, 2), 'info');
                
                updateStatus('‚úÖ Results processing test passed!', 'success');
                log('=== Test Completed ===', 'success');
            } catch (error) {
                log('=== Test Failed ===', 'error');
                log('Error: ' + error.message, 'error');
                updateStatus('‚ùå Test failed: ' + error.message, 'error');
            }
        }

        // Initial log
        log('Test page loaded. Ready to test simulation completion handling.', 'info');
    </script>
</body>
</html>
