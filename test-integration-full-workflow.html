<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Full Integration Test - Real Backend</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: #1a1a1a;
            color: #e0e0e0;
        }
        
        h1 {
            color: #4CAF50;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 10px;
        }
        
        h2 {
            color: #2196F3;
            margin-top: 30px;
        }
        
        .test-section {
            background: #2a2a2a;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid #2196F3;
        }
        
        .test-case {
            background: #333;
            border-radius: 4px;
            padding: 15px;
            margin: 10px 0;
            border-left: 3px solid #666;
        }
        
        .test-case.running {
            border-left-color: #FFC107;
            background: #3a3520;
        }
        
        .test-case.passed {
            border-left-color: #4CAF50;
            background: #1e3a1e;
        }
        
        .test-case.failed {
            border-left-color: #f44336;
            background: #3a1e1e;
        }
        
        .test-controls {
            display: flex;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        button {
            background: #2196F3;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #1976D2;
        }
        
        button:disabled {
            background: #555;
            cursor: not-allowed;
        }
        
        button.danger {
            background: #f44336;
        }
        
        button.danger:hover {
            background: #d32f2f;
        }
        
        .status {
            padding: 8px 16px;
            border-radius: 4px;
            display: inline-block;
            font-weight: 500;
            margin: 5px 0;
        }
        
        .status.pending { background: #666; }
        .status.running { background: #FFC107; color: #000; }
        .status.passed { background: #4CAF50; }
        .status.failed { background: #f44336; }
        
        .log-output {
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 15px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .log-entry {
            margin: 2px 0;
            padding: 2px 0;
        }
        
        .log-entry.info { color: #2196F3; }
        .log-entry.success { color: #4CAF50; }
        .log-entry.warning { color: #FFC107; }
        .log-entry.error { color: #f44336; }
        
        .progress-bar {
            width: 100%;
            height: 24px;
            background: #444;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #2196F3, #4CAF50);
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            font-weight: 500;
        }
        
        .test-results {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .result-card {
            background: #333;
            border-radius: 4px;
            padding: 15px;
            text-align: center;
        }
        
        .result-value {
            font-size: 32px;
            font-weight: bold;
            margin: 10px 0;
        }
        
        .result-label {
            color: #999;
            font-size: 14px;
        }
        
        .parameter-display {
            background: #2a2a2a;
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        
        .discrepancy {
            background: #3a1e1e;
            border-left: 3px solid #f44336;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        
        .summary {
            background: #2a2a2a;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            border: 2px solid #4CAF50;
        }
    </style>
</head>
<body>
    <h1>üß™ Full Integration Test - Real Backend Simulation</h1>
    
    <div class="test-section">
        <h2>Test Overview</h2>
        <p>This comprehensive test validates the complete simulation workflow from parameter input through backend execution to results display.</p>
        <p><strong>Requirements Validated:</strong> All requirements from physics-heat-simulation spec</p>
    </div>
    
    <div class="test-controls">
        <button id="runAllTests" onclick="runAllTests()">‚ñ∂Ô∏è Run All Tests</button>
        <button id="runMaterialTests" onclick="runMaterialTests()">üî¨ Test Materials</button>
        <button id="runGeometryTests" onclick="runGeometryTests()">üìê Test Geometries</button>
        <button id="runTorchTests" onclick="runTorchTests()">üî• Test Torch Positions</button>
        <button id="clearLogs" onclick="clearLogs()">üóëÔ∏è Clear Logs</button>
    </div>
    
    <div class="test-results">
        <div class="result-card">
            <div class="result-label">Total Tests</div>
            <div class="result-value" id="totalTests">0</div>
        </div>
        <div class="result-card">
            <div class="result-label">Passed</div>
            <div class="result-value" style="color: #4CAF50;" id="passedTests">0</div>
        </div>
        <div class="result-card">
            <div class="result-label">Failed</div>
            <div class="result-value" style="color: #f44336;" id="failedTests">0</div>
        </div>
        <div class="result-card">
            <div class="result-label">Running</div>
            <div class="result-value" style="color: #FFC107;" id="runningTests">0</div>
        </div>
    </div>
    
    <div class="progress-bar">
        <div class="progress-fill" id="overallProgress" style="width: 0%;">0%</div>
    </div>
    
    <div id="testContainer"></div>
    
    <div class="log-output" id="logOutput"></div>
    
    <div class="summary" id="summary" style="display: none;">
        <h2>üìä Test Summary</h2>
        <div id="summaryContent"></div>
    </div>

    <script>
        // Test state
        const testState = {
            total: 0,
            passed: 0,
            failed: 0,
            running: 0,
            tests: [],
            discrepancies: []
        };
        
        // Logging utility
        function log(message, type = 'info') {
            const logOutput = document.getElementById('logOutput');
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${timestamp}] ${message}`;
            logOutput.appendChild(entry);
            logOutput.scrollTop = logOutput.scrollHeight;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }
        
        function clearLogs() {
            document.getElementById('logOutput').innerHTML = '';
            log('Logs cleared', 'info');
        }
        
        // Update test statistics
        function updateStats() {
            document.getElementById('totalTests').textContent = testState.total;
            document.getElementById('passedTests').textContent = testState.passed;
            document.getElementById('failedTests').textContent = testState.failed;
            document.getElementById('runningTests').textContent = testState.running;
            
            const progress = testState.total > 0 ? 
                ((testState.passed + testState.failed) / testState.total * 100) : 0;
            const progressBar = document.getElementById('overallProgress');
            progressBar.style.width = progress + '%';
            progressBar.textContent = Math.round(progress) + '%';
        }
        
        // Create test case UI
        function createTestCase(id, title, description) {
            const container = document.getElementById('testContainer');
            const testCase = document.createElement('div');
            testCase.id = `test-${id}`;
            testCase.className = 'test-case';
            testCase.innerHTML = `
                <h3>${title}</h3>
                <p>${description}</p>
                <div class="status pending" id="status-${id}">Pending</div>
                <div class="parameter-display" id="params-${id}" style="display: none;"></div>
                <div id="results-${id}" style="display: none;"></div>
            `;
            container.appendChild(testCase);
            
            testState.tests.push({ id, title, status: 'pending' });
            testState.total++;
            updateStats();
            
            return id;
        }
        
        // Update test status
        function updateTestStatus(id, status, message = '') {
            const testCase = document.getElementById(`test-${id}`);
            const statusEl = document.getElementById(`status-${id}`);
            
            if (testCase) {
                testCase.className = `test-case ${status}`;
            }
            
            if (statusEl) {
                statusEl.className = `status ${status}`;
                statusEl.textContent = status.charAt(0).toUpperCase() + status.slice(1);
                if (message) {
                    statusEl.textContent += `: ${message}`;
                }
            }
            
            // Update counts
            const test = testState.tests.find(t => t.id === id);
            if (test) {
                const oldStatus = test.status;
                test.status = status;
                
                if (oldStatus === 'running') testState.running--;
                if (status === 'running') testState.running++;
                if (status === 'passed') testState.passed++;
                if (status === 'failed') testState.failed++;
            }
            
            updateStats();
        }
        
        // Display test parameters
        function displayParameters(id, params) {
            const paramsEl = document.getElementById(`params-${id}`);
            if (paramsEl) {
                paramsEl.style.display = 'block';
                paramsEl.textContent = JSON.stringify(params, null, 2);
            }
        }
        
        // Display test results
        function displayResults(id, results) {
            const resultsEl = document.getElementById(`results-${id}`);
            if (resultsEl) {
                resultsEl.style.display = 'block';
                resultsEl.innerHTML = `<pre>${JSON.stringify(results, null, 2)}</pre>`;
            }
        }
        
        // Record discrepancy
        function recordDiscrepancy(testId, expected, actual, description) {
            testState.discrepancies.push({
                testId,
                expected,
                actual,
                description,
                timestamp: new Date().toISOString()
            });
            
            const resultsEl = document.getElementById(`results-${testId}`);
            if (resultsEl) {
                const discrepancy = document.createElement('div');
                discrepancy.className = 'discrepancy';
                discrepancy.innerHTML = `
                    <strong>‚ö†Ô∏è Discrepancy:</strong> ${description}<br>
                    <strong>Expected:</strong> ${JSON.stringify(expected)}<br>
                    <strong>Actual:</strong> ${JSON.stringify(actual)}
                `;
                resultsEl.appendChild(discrepancy);
            }
        }
        
        // Wait for simulation completion
        async function waitForSimulation(simulationId, timeout = 300000) {
            const startTime = Date.now();
            
            return new Promise((resolve, reject) => {
                const checkInterval = setInterval(async () => {
                    try {
                        if (Date.now() - startTime > timeout) {
                            clearInterval(checkInterval);
                            reject(new Error('Simulation timeout'));
                            return;
                        }
                        
                        const status = await window.__TAURI__.core.invoke('get_simulation_status', {
                            simulationId: simulationId
                        });
                        
                        if (status.progress) {
                            const progress = status.progress;
                            
                            if (progress.status === 'Completed') {
                                clearInterval(checkInterval);
                                resolve(progress);
                            } else if (progress.status === 'Failed') {
                                clearInterval(checkInterval);
                                reject(new Error(`Simulation failed: ${progress.status}`));
                            } else if (progress.status === 'Cancelled') {
                                clearInterval(checkInterval);
                                reject(new Error('Simulation was cancelled'));
                            }
                        }
                    } catch (error) {
                        clearInterval(checkInterval);
                        reject(error);
                    }
                }, 1000);
            });
        }
        
        // Run a single simulation test
        async function runSimulationTest(testId, parameters, validationFn) {
            try {
                updateTestStatus(testId, 'running');
                displayParameters(testId, parameters);
                log(`Starting test ${testId}...`, 'info');
                
                // Start simulation
                const result = await window.__TAURI__.core.invoke('run_simulation', {
                    parameters: parameters
                });
                
                if (!result.success) {
                    throw new Error(result.message || 'Failed to start simulation');
                }
                
                log(`Simulation ${result.simulation_id} started`, 'success');
                
                // Wait for completion
                log(`Waiting for simulation ${result.simulation_id} to complete...`, 'info');
                const progress = await waitForSimulation(result.simulation_id);
                
                log(`Simulation ${result.simulation_id} completed`, 'success');
                
                // Get results
                const results = await window.__TAURI__.core.invoke('get_simulation_results', {
                    simulationId: result.simulation_id
                });
                
                displayResults(testId, results);
                
                // Validate results
                if (validationFn) {
                    const validation = await validationFn(results, parameters);
                    if (validation.passed) {
                        updateTestStatus(testId, 'passed', validation.message);
                        log(`Test ${testId} passed: ${validation.message}`, 'success');
                    } else {
                        updateTestStatus(testId, 'failed', validation.message);
                        log(`Test ${testId} failed: ${validation.message}`, 'error');
                        if (validation.discrepancy) {
                            recordDiscrepancy(testId, validation.expected, validation.actual, validation.discrepancy);
                        }
                    }
                } else {
                    updateTestStatus(testId, 'passed', 'Simulation completed');
                    log(`Test ${testId} completed`, 'success');
                }
                
                return { success: true, results };
                
            } catch (error) {
                updateTestStatus(testId, 'failed', error.message);
                log(`Test ${testId} failed: ${error.message}`, 'error');
                return { success: false, error: error.message };
            }
        }
        
        // Material tests
        async function runMaterialTests() {
            log('=== Starting Material Tests ===', 'info');
            
            const materials = ['Steel', 'Aluminum', 'Concrete'];
            const baseParams = {
                geometry: {
                    cylinder_height: 2.0,
                    cylinder_radius: 1.0
                },
                mesh: {
                    preset: 'fast',
                    nr: 10,
                    nz: 10
                },
                torches: {
                    torches: [{
                        position: { r: 0.0, z: 0.0 },
                        power: 150.0,
                        efficiency: 0.8,
                        sigma: 0.1
                    }]
                },
                simulation: {
                    total_time: 30.0,
                    solver_method: 'forward-euler',
                    cfl_factor: 0.5,
                    output_interval: 1.0
                },
                boundary: {
                    initial_temperature: 300.0,
                    ambient_temperature: 300.0
                },
                materials: {
                    material_type: 'Steel'
                }
            };
            
            for (const material of materials) {
                const testId = createTestCase(
                    `material-${material.toLowerCase()}`,
                    `Material Test: ${material}`,
                    `Test heat diffusion with ${material} material properties`
                );
                
                const params = { ...baseParams, materials: { material_type: material } };
                
                await runSimulationTest(testId, params, (results, params) => {
                    // Validate that simulation completed with material-specific behavior
                    if (results.status === 'completed') {
                        return {
                            passed: true,
                            message: `${material} simulation completed successfully`
                        };
                    }
                    return {
                        passed: false,
                        message: 'Simulation did not complete'
                    };
                });
            }
        }
        
        // Geometry tests
        async function runGeometryTests() {
            log('=== Starting Geometry Tests ===', 'info');
            
            const geometries = [
                { height: 2.0, radius: 1.0, name: '2m x 1m' },
                { height: 4.0, radius: 1.0, name: '4m x 1m' },
                { height: 2.0, radius: 0.5, name: '2m x 0.5m' }
            ];
            
            for (const geom of geometries) {
                const testId = createTestCase(
                    `geometry-${geom.height}x${geom.radius}`,
                    `Geometry Test: ${geom.name}`,
                    `Test with furnace dimensions ${geom.height}m height x ${geom.radius}m radius`
                );
                
                const params = {
                    geometry: {
                        cylinder_height: geom.height,
                        cylinder_radius: geom.radius
                    },
                    mesh: {
                        preset: 'fast',
                        nr: 10,
                        nz: 10
                    },
                    torches: {
                        torches: [{
                            position: { r: 0.0, z: 0.0 },
                            power: 150.0,
                            efficiency: 0.8,
                            sigma: 0.1
                        }]
                    },
                    simulation: {
                        total_time: 30.0,
                        solver_method: 'forward-euler',
                        cfl_factor: 0.5,
                        output_interval: 1.0
                    },
                    boundary: {
                        initial_temperature: 300.0,
                        ambient_temperature: 300.0
                    },
                    materials: {
                        material_type: 'Steel'
                    }
                };
                
                await runSimulationTest(testId, params, (results, params) => {
                    if (results.status === 'completed') {
                        return {
                            passed: true,
                            message: `Geometry ${geom.name} completed successfully`
                        };
                    }
                    return {
                        passed: false,
                        message: 'Simulation did not complete'
                    };
                });
            }
        }
        
        // Torch position tests
        async function runTorchTests() {
            log('=== Starting Torch Position Tests ===', 'info');
            
            const positions = [
                { r: 0.0, z: 0.0, name: 'Bottom Center' },
                { r: 0.5, z: 0.5, name: 'Middle' },
                { r: 1.0, z: 1.0, name: 'Top Edge' }
            ];
            
            for (const pos of positions) {
                const testId = createTestCase(
                    `torch-${pos.r}-${pos.z}`,
                    `Torch Position Test: ${pos.name}`,
                    `Test with torch at normalized position (r=${pos.r}, z=${pos.z})`
                );
                
                const params = {
                    geometry: {
                        cylinder_height: 2.0,
                        cylinder_radius: 1.0
                    },
                    mesh: {
                        preset: 'fast',
                        nr: 10,
                        nz: 10
                    },
                    torches: {
                        torches: [{
                            position: { r: pos.r, z: pos.z },
                            power: 150.0,
                            efficiency: 0.8,
                            sigma: 0.1
                        }]
                    },
                    simulation: {
                        total_time: 30.0,
                        solver_method: 'forward-euler',
                        cfl_factor: 0.5,
                        output_interval: 1.0
                    },
                    boundary: {
                        initial_temperature: 300.0,
                        ambient_temperature: 300.0
                    },
                    materials: {
                        material_type: 'Steel'
                    }
                };
                
                await runSimulationTest(testId, params, (results, params) => {
                    if (results.status === 'completed') {
                        return {
                            passed: true,
                            message: `Torch position ${pos.name} completed successfully`
                        };
                    }
                    return {
                        passed: false,
                        message: 'Simulation did not complete'
                    };
                });
            }
        }
        
        // Run all tests
        async function runAllTests() {
            log('=== Starting Full Integration Test Suite ===', 'info');
            
            // Reset state
            testState.total = 0;
            testState.passed = 0;
            testState.failed = 0;
            testState.running = 0;
            testState.tests = [];
            testState.discrepancies = [];
            document.getElementById('testContainer').innerHTML = '';
            document.getElementById('summary').style.display = 'none';
            
            // Run all test suites
            await runMaterialTests();
            await runGeometryTests();
            await runTorchTests();
            
            // Show summary
            showSummary();
        }
        
        // Show test summary
        function showSummary() {
            const summary = document.getElementById('summary');
            const content = document.getElementById('summaryContent');
            
            const passRate = testState.total > 0 ? 
                (testState.passed / testState.total * 100).toFixed(1) : 0;
            
            let html = `
                <p><strong>Total Tests:</strong> ${testState.total}</p>
                <p><strong>Passed:</strong> ${testState.passed} (${passRate}%)</p>
                <p><strong>Failed:</strong> ${testState.failed}</p>
            `;
            
            if (testState.discrepancies.length > 0) {
                html += `<h3>‚ö†Ô∏è Discrepancies Found (${testState.discrepancies.length})</h3>`;
                testState.discrepancies.forEach(d => {
                    html += `
                        <div class="discrepancy">
                            <strong>Test:</strong> ${d.testId}<br>
                            <strong>Issue:</strong> ${d.description}<br>
                            <strong>Expected:</strong> ${JSON.stringify(d.expected)}<br>
                            <strong>Actual:</strong> ${JSON.stringify(d.actual)}
                        </div>
                    `;
                });
            } else {
                html += `<p style="color: #4CAF50;">‚úÖ No discrepancies found!</p>`;
            }
            
            content.innerHTML = html;
            summary.style.display = 'block';
            
            log(`=== Test Suite Complete: ${testState.passed}/${testState.total} passed ===`, 
                testState.failed === 0 ? 'success' : 'warning');
        }
        
        // Initialize
        window.addEventListener('DOMContentLoaded', () => {
            log('Integration test page loaded', 'info');
            log('Ready to run tests', 'success');
            
            // Check if Tauri is available
            if (window.__TAURI__) {
                log('‚úÖ Tauri backend detected', 'success');
            } else {
                log('‚ö†Ô∏è Tauri backend not detected - tests will fail', 'warning');
            }
        });
    </script>
</body>
</html>
