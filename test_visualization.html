<!DOCTYPE html>
<html>
<head>
    <title>Test 3D Visualization</title>
    <style>
        body { margin: 0; padding: 20px; font-family: Arial, sans-serif; }
        #container { width: 800px; height: 600px; border: 1px solid #ccc; position: relative; }
        #canvas { width: 100%; height: 100%; }
        .controls { margin: 10px 0; }
        .controls button { margin-right: 10px; padding: 5px 10px; }
    </style>
</head>
<body>
    <h1>3D Heatmap Visualization Test</h1>
    <div class="controls">
        <button onclick="loadTestData()">Load Test Data</button>
        <button onclick="resetCamera()">Reset Camera</button>
        <button onclick="toggleWireframe()">Toggle Wireframe</button>
    </div>
    <div id="container">
        <canvas id="canvas"></canvas>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/controls/OrbitControls.js"></script>
    
    <script>
        let scene, camera, renderer, controls, heatmapMesh;
        let wireframeMode = false;

        function init() {
            const container = document.getElementById('container');
            const canvas = document.getElementById('canvas');

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);

            // Camera
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(3, 3, 3);

            // Renderer
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);

            // Axes
            const axesHelper = new THREE.AxesHelper(2);
            scene.add(axesHelper);

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function getTemperatureColor(temperature, minTemp, maxTemp) {
            const normalized = (temperature - minTemp) / (maxTemp - minTemp);
            
            let r, g, b;
            if (normalized < 0.25) {
                const t = normalized / 0.25;
                r = 0; g = t; b = 1;
            } else if (normalized < 0.5) {
                const t = (normalized - 0.25) / 0.25;
                r = 0; g = 1; b = 1 - t;
            } else if (normalized < 0.75) {
                const t = (normalized - 0.5) / 0.25;
                r = t; g = 1; b = 0;
            } else {
                const t = (normalized - 0.75) / 0.25;
                r = 1; g = 1 - t; b = 0;
            }
            
            return new THREE.Color(r, g, b);
        }

        function loadTestData() {
            // Test data similar to what the Tauri backend provides
            const testData = {
                mesh_points: [
                    {x: 0.0, y: 0.0, z: 0.0}, {x: 0.5, y: 0.0, z: 0.0}, {x: 1.0, y: 0.0, z: 0.0},
                    {x: 0.0, y: 0.0, z: 1.0}, {x: 0.5, y: 0.0, z: 1.0}, {x: 1.0, y: 0.0, z: 1.0},
                    {x: 0.0, y: 0.0, z: 2.0}, {x: 0.5, y: 0.0, z: 2.0}, {x: 1.0, y: 0.0, z: 2.0}
                ],
                temperature_values: [300.0, 400.0, 350.0, 500.0, 800.0, 600.0, 400.0, 600.0, 450.0],
                metadata: {
                    min_temperature: 300.0,
                    max_temperature: 800.0
                }
            };

            // Remove existing mesh
            if (heatmapMesh) {
                scene.remove(heatmapMesh);
            }

            // Create geometry
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];

            for (let i = 0; i < testData.mesh_points.length; i++) {
                const point = testData.mesh_points[i];
                const temperature = testData.temperature_values[i];

                positions.push(point.x, point.y, point.z);

                const color = getTemperatureColor(temperature, testData.metadata.min_temperature, testData.metadata.max_temperature);
                colors.push(color.r, color.g, color.b);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            // Create material and mesh
            const material = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });

            heatmapMesh = new THREE.Points(geometry, material);
            scene.add(heatmapMesh);

            console.log('Test data loaded successfully');
        }

        function resetCamera() {
            camera.position.set(3, 3, 3);
            camera.lookAt(0, 0, 1);
            controls.reset();
        }

        function toggleWireframe() {
            wireframeMode = !wireframeMode;
            if (heatmapMesh && heatmapMesh.material) {
                heatmapMesh.material.wireframe = wireframeMode;
            }
        }

        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>